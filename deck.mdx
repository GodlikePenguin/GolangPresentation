export { default as theme } from 'Theme'
import { Split } from 'mdx-deck/layouts'
import Fullscreen from 'components/Fullscreen'
import HiLight from 'components/HighlightedBlock'
import Cool from 'components/CoolFeature'

<Fullscreen />

# A Presentation on Golang

![golang gopher](public/img/gopher.png)

<br />
<small>
Edward Dobson
</small>
---
## Contents
- Introduction to Go

<small>Todorova, Magdalina, et al. "The Go Programming Language: Characteristics and Capabilities." Annual of “Informatics” Section Union of Scientists in Bulgaria 6: 76-85.</small>

- Concurrency

<small>Prabhakar, Raghu, and Rohit Kumar. Concurrent Programming in Go. Google, Tech. Rep, 2011.</small>

---
## Background
- Go was developed at Google in 2007 and v1.0 was publicly released in 2012
- It was intended to couple the benefits of safety and speed from strictly typed languages with the readability and usability from dynamically typed languages
- Looks "C like" but with lots of the syntactic sugar of more modern languages
- Multi paradigm, but mainly used for networking and systems applications

```notes
Here safety refers to both type and memory safety

Runtime and compilation speed
```
---
## Goals in depth
- Easy to learn and write
- Type safety and memory safety
- Easy concurrency
- Low latency garbage collection
- Fast compilation and execution
---
## Hello World
```go
package main

import "fmt"

func main() {
  var message string
  message = "Hello world"
  fmt.Println(message)
}
```
- Go explicitly uses a keyword (`func`, `var`) as well as the type

<em>except when using...</em>

---

## Type Inference
<Cool num='1' />

```go
var message string
message = "Hello world"
// is the same as
var message = "Hello world"
// is the same as
message := "Hello world"
```
- The type, and even the var keyword in variable declarations are optional

---
## Type system
- Strongly typed (No implicit conversions)
- Statically typed (Although more freedom than C)
- Pseudo Object Oriented

❌          | ✅
------------|-------------
Classes     | Structs
Inheritence | Interfaces
Generics    | People who pretend they don't need generics

---
## Structs

```go
type Person struct {
  FirstName string
  LastName string
}

p := Person{FirstName: "John"}
fmt.Println(p.FirstName) // prints 'John'
```

- A Struct is a typed collection of fields, each of which can be accessed by dot notation
- Dot notation for both pointer and non pointer types (I am looking at you C++)

---
## Struct methods
```go
func (p Person) String() string {
  return p.FirstName + " " + p.LastName
}

p := Person{FirstName: "John", "Smith"}
fmt.Println(p.String()) // prints 'John Smith'
```

- You can also add methods to structs, by specifing the struct type as part of the method signature
- These are also accessed by dot notation

---
## Interfaces

```go
type Stringer interface {
  String() string
}  
```
- We use interfaces to specify a 'type' which implements one or more methods
- We don't care about the implementation of those methods, but the argument and return type must match
- A struct implicitly implements an interface without the need for a decorator (e.g. `class Foo implements Bah` in Java)

---
## Embedded types: Pseudo Inheritence
```go
type Employee struct {
  Person
  Job string
}
```
- If a field in a struct is not named, all it's attributes and methods are applied directly to the outer struct
- This **DOES NOT** mean we can use an `Employee` as a `Person`, they are still separate types
- Similar to private inheritence from C++

---
## What are we missing


<div style={{fontSize: '1.5em', textAlign: 'left', marginTop: '50px'}}>Mentioned before:</div>

- Inheritence
- Generics

<div style={{fontSize: '1.5em', textAlign: 'left',}}>Not mentioned:</div>

- Operator or Function overloading

---
## Concurrency

Sticking with the goal of simplicity...
---
## Goroutines
- A goroutine is a lightweight thread of execution.
- Allows you to run a function in another thread
- Goroutines run in the same address space so access to shared memory can cause race conditions
- Channels (message passing) are a thread safe way for goroutines to communicate 
---
## Starting a new goroutine
```go
func reallyUsefulMethod(message string) {
  fmt.Println(message)
}

go reallyUsefulMethod("Hello from another goroutine")
```
- As simple as just placing the `go` keyword before a function call
---
## Channels

- Channels are a typed conduit through which you can send and receive values
- Can be simplex or duplex
---
Enough boring talk, lets see concurrency in action
<RunnableBlock value={`package main
+S
import "math"
+S
func main() {
	//Create a channel of input numbers
	in := make(chan float64, 10)
	//Create a channel of input numbers
	out := make(chan float64, 10)
	//The numbers to find the square roots of
	inNums := []float64{36.0, 49.0, 64.0}
	//Put the numbers in the in channel
	for _, num := range inNums {
		in <- num
	}
	//Closing a channel means we're not going to send
  // anything else on it
	close(in)
	//Start a goroutine
	go sqrt(in, out)
	println("waiting for responses")
	//Iterate through the responses and print them
	for num := range out {
		println(num)
	}
}
+S
func sqrt(in <-chan float64, out chan<- float64) {
	//loop through the input numbers and place the 
  // resulting square root in the output channel
	//This loop will keep running until the 'in'
  // channel is closed
	for num := range in {
		out <- math.Sqrt(num)
	}
	//Close the out channel so the main thread knows
  // we're done
	close(out)
}`}
  initialOutput={`6
  7
  8`}
  height="600px" />
---












Everything after this slide is a maybe

---
## Functions
Quite a few nifty features that you don't find in C
---
## Multiple return values
```go
func head(list []string) (string, []string) {
	return list[0], list[1:]
}

func main() {
	myList := []string{"The", "quick", "brown", "fox"}
	head, rest := head(myList)
	fmt.Println(head, rest)
}
//Will print "The [quick brown fox]"
```
- Brackets around the return types may suggest a tuple, but they are returned separately
---
## Named return values
```go
func sayHello(name string) (message string) {
  message = fmt.Sprintf("Hello %s", name)
  return
}
```
- Assigning a name to the return type(s) of a function declaration allows us to use the return keyword, without specifiying the value
---
## Defer
```go
func readFile(fileName string) []byte {
  f, _ := os.Open(fileName)
  defer f.Close()

  data, _ := ioutil.ReadAll(f)
  return data
}
```
- We can use the `defer` keyword to manually push a function to the call stack so that it is executed when the current function finishes
- Defer can be called multiple times, with the last defer call being executed first (LIFO)

---
## Interactive Hello world
import RunnableBlock from 'components/RunnableBlock'

<RunnableBlock value={`package main
func main() {
  println("hello wld")
}`}
  initialOutput={'hello wld'} />

---
The end
