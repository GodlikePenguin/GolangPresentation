export { default as theme } from 'Theme'
import Fullscreen from 'components/Fullscreen'
import HiLight from 'components/HighlightedBlock'

<Fullscreen />

# A Presentation on Golang

![golang gopher](public/img/gopher.png)

<br />
<small>
Edward Dobson
</small>
---
## Background
- Go was developed at Google in 2007 and publicly released in 2012
- It was intended to couple the benefits of safety and speed from strictly typed languages with the readability and usability from dynamically typed languages
- Looks "C like" but with lots of the syntactic sugar of more modern languages
- Multi paradigm, but mainly used for networking and systems applications

```notes
Here safety refers to both type and memory safety

Runtime and compilation speed
```
---
## Goals in depth
- Easy to learn and write
- Type safety and memory safety
- Easy concurrency
- Low latency garbage collection
- Fast compilation and execution
---
## Basic hello world
```go
package main

import "fmt"

func main() {
  var message string
  message = "Hello world"
  fmt.Println(message)
}
```
- Go explicitly uses a keyword (`func`, `var`) as well as the type (<small>_Most of the time_</small>)

---
## Type inference
```go
var message string
message = "Hello world"
// is the same as
var message = "Hello world"
// is the same as
message := "Hello world"
```
- The type, and even the var keyword in variable declarations are optional
---
## Functions
Quite a few nifty features that you don't find in C
---
## Multiple return values
```go
func head(list []string) (string, []string) {
	return list[0], list[1:]
}

func main() {
	myList := []string{"The", "quick", "brown", "fox"}
	head, rest := head(myList)
	fmt.Println(head, rest)
}
//Will print "The [quick brown fox]"
```
- Brackets around the return types may suggest a tuple, but they are returned separately
---
## Named return values
```go
func sayHello(name string) (message string) {
  message = fmt.Sprintf("Hello %s", name)
  return
}
```
- Assigning a name to the return type(s) of a function declaration allows us to use the return keyword, without specifiying the value
---
## Defer
```go
func readFile(fileName string) []byte {
  f, _ := os.Open(fileName)
  defer f.Close()

  data, _ := ioutil.ReadAll(f)
  return data
}
```
- We can use the `defer` keyword to manually push a function to the call stack so that it is executed when the current function finishes
- Defer can be called multiple times, with the last defer call being executed first (LIFO)
---
## Polymorphism
---
## Interactive Hello world
import RunnableBlock from 'components/RunnableBlock'

<RunnableBlock value={`package main
func main() {
  println("hello wld")
}`}
  initialOutput={'hello wld'} />

---
The end
